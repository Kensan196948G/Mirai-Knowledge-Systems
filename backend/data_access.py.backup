"""
データアクセスレイヤー
JSON/PostgreSQLの切り替えを透過的に行う
"""
import os
import json
from typing import List, Optional, Dict, Any
from datetime import datetime

from config import Config
from database import SessionLocal
from models import Knowledge, SOP, Incident, Consultation, Approval, Notification, User, AccessLog


class DataAccessLayer:
    """データアクセス抽象化レイヤー"""

    def __init__(self, use_postgresql=None):
        """
        初期化

        Args:
            use_postgresql: PostgreSQLを使用するかどうか（Noneの場合は環境変数から取得）
        """
        if use_postgresql is None:
            use_postgresql = Config.USE_POSTGRESQL
        self.use_postgresql = use_postgresql
        self.data_dir = Config.DATA_DIR

    def _get_json_path(self, filename):
        """JSONファイルのパスを取得"""
        return os.path.join(self.data_dir, filename)

    def _load_json(self, filename):
        """JSONファイルからデータを読み込み"""
        filepath = self._get_json_path(filename)
        if os.path.exists(filepath):
            try:
                with open(filepath, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    if not isinstance(data, list):
                        return []
                    return [item for item in data if isinstance(item, dict)]
            except (json.JSONDecodeError, ValueError):
                return []
        return []

    def _save_json(self, filename, data):
        """JSONファイルにデータを保存"""
        filepath = self._get_json_path(filename)
        dirpath = os.path.dirname(filepath)
        os.makedirs(dirpath, exist_ok=True)

        import tempfile
        fd, tmp_path = tempfile.mkstemp(prefix=f".{filename}.", suffix=".tmp", dir=dirpath)
        try:
            with os.fdopen(fd, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            os.replace(tmp_path, filepath)
        finally:
            if os.path.exists(tmp_path):
                os.remove(tmp_path)

    # ============================================================
    # ナレッジ（Knowledge）
    # ============================================================

    def get_knowledge_list(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict]:
        """
        ナレッジ一覧を取得

        Args:
            filters: フィルタ条件 (category, search, tags など)

        Returns:
            ナレッジリスト
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                query = db.query(Knowledge)

                # フィルタリング
                if filters:
                    if 'category' in filters:
                        query = query.filter(Knowledge.category == filters['category'])
                    if 'search' in filters:
                        search_term = f"%{filters['search']}%"
                        query = query.filter(
                            (Knowledge.title.ilike(search_term)) |
                            (Knowledge.summary.ilike(search_term)) |
                            (Knowledge.content.ilike(search_term))
                        )

                results = query.order_by(Knowledge.updated_at.desc()).all()
                return [self._knowledge_to_dict(k) for k in results]
            finally:
                db.close()
        else:
            data = self._load_json('knowledge.json')

            # フィルタリング
            if filters:
                if 'category' in filters:
                    data = [k for k in data if k.get('category') == filters['category']]
                if 'search' in filters:
                    search_term = filters['search'].lower()
                    data = [k for k in data if
                           search_term in k.get('title', '').lower() or
                           search_term in k.get('summary', '').lower() or
                           search_term in k.get('content', '').lower()]

            return data

    def get_knowledge_by_id(self, knowledge_id: int) -> Optional[Dict]:
        """
        ナレッジをIDで取得

        Args:
            knowledge_id: ナレッジID

        Returns:
            ナレッジデータ（見つからない場合はNone）
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                knowledge = db.query(Knowledge).filter(Knowledge.id == knowledge_id).first()
                return self._knowledge_to_dict(knowledge) if knowledge else None
            finally:
                db.close()
        else:
            data = self._load_json('knowledge.json')
            return next((k for k in data if k['id'] == knowledge_id), None)

    def create_knowledge(self, knowledge_data: Dict) -> Dict:
        """
        ナレッジを作成

        Args:
            knowledge_data: ナレッジデータ

        Returns:
            作成されたナレッジデータ
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                knowledge = Knowledge(
                    title=knowledge_data['title'],
                    summary=knowledge_data['summary'],
                    content=knowledge_data.get('content'),
                    category=knowledge_data['category'],
                    tags=knowledge_data.get('tags', []),
                    status=knowledge_data.get('status', 'draft'),
                    priority=knowledge_data.get('priority', 'medium'),
                    project=knowledge_data.get('project'),
                    owner=knowledge_data['owner'],
                    created_by_id=knowledge_data.get('created_by_id')
                )
                db.add(knowledge)
                db.commit()
                db.refresh(knowledge)
                return self._knowledge_to_dict(knowledge)
            except Exception as e:
                db.rollback()
                raise
            finally:
                db.close()
        else:
            data = self._load_json('knowledge.json')
            new_id = max([k['id'] for k in data], default=0) + 1

            new_knowledge = {
                'id': new_id,
                'title': knowledge_data['title'],
                'summary': knowledge_data['summary'],
                'content': knowledge_data.get('content'),
                'category': knowledge_data['category'],
                'tags': knowledge_data.get('tags', []),
                'status': knowledge_data.get('status', 'draft'),
                'priority': knowledge_data.get('priority', 'medium'),
                'project': knowledge_data.get('project'),
                'owner': knowledge_data['owner'],
                'created_at': datetime.now().isoformat(),
                'updated_at': datetime.now().isoformat(),
                'created_by_id': knowledge_data.get('created_by_id')
            }

            data.append(new_knowledge)
            self._save_json('knowledge.json', data)
            return new_knowledge

    def update_knowledge(self, knowledge_id: int, knowledge_data: Dict) -> Optional[Dict]:
        """
        ナレッジを更新

        Args:
            knowledge_id: ナレッジID
            knowledge_data: 更新データ

        Returns:
            更新されたナレッジデータ（見つからない場合はNone）
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                knowledge = db.query(Knowledge).filter(Knowledge.id == knowledge_id).first()
                if not knowledge:
                    return None

                for key, value in knowledge_data.items():
                    if hasattr(knowledge, key) and key not in ['id', 'created_at']:
                        setattr(knowledge, key, value)

                knowledge.updated_at = datetime.utcnow()
                db.commit()
                db.refresh(knowledge)
                return self._knowledge_to_dict(knowledge)
            except Exception as e:
                db.rollback()
                raise
            finally:
                db.close()
        else:
            data = self._load_json('knowledge.json')
            knowledge = next((k for k in data if k['id'] == knowledge_id), None)

            if not knowledge:
                return None

            for key, value in knowledge_data.items():
                if key != 'id':
                    knowledge[key] = value

            knowledge['updated_at'] = datetime.now().isoformat()
            self._save_json('knowledge.json', data)
            return knowledge

    def delete_knowledge(self, knowledge_id: int) -> bool:
        """
        ナレッジを削除

        Args:
            knowledge_id: ナレッジID

        Returns:
            削除成功時True
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                knowledge = db.query(Knowledge).filter(Knowledge.id == knowledge_id).first()
                if not knowledge:
                    return False

                db.delete(knowledge)
                db.commit()
                return True
            except Exception as e:
                db.rollback()
                raise
            finally:
                db.close()
        else:
            data = self._load_json('knowledge.json')
            original_length = len(data)
            data = [k for k in data if k['id'] != knowledge_id]

            if len(data) < original_length:
                self._save_json('knowledge.json', data)
                return True
            return False

    # ============================================================
    # 通知（Notification）
    # ============================================================

    def get_notifications(self, user_id: int = None, filters: Dict = None) -> List[Dict]:
        """
        通知一覧を取得

        Args:
            user_id: ユーザーID（指定時はそのユーザー向けの通知のみ）
            filters: フィルタ条件

        Returns:
            通知リスト
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                query = db.query(Notification)

                if user_id:
                    # PostgreSQLの配列検索
                    query = query.filter(
                        (Notification.target_users.any(user_id))
                    )

                results = query.order_by(Notification.created_at.desc()).all()
                return [self._notification_to_dict(n) for n in results]
            finally:
                db.close()
        else:
            data = self._load_json('notifications.json')

            if user_id:
                # ユーザーIDがtarget_usersに含まれる通知のみ
                data = [n for n in data if user_id in n.get('target_users', [])]

            return sorted(data, key=lambda x: x.get('created_at', ''), reverse=True)

    def create_notification(self, notification_data: Dict) -> Dict:
        """
        通知を作成

        Args:
            notification_data: 通知データ

        Returns:
            作成された通知データ
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                notification = Notification(
                    title=notification_data['title'],
                    message=notification_data['message'],
                    type=notification_data['type'],
                    target_users=notification_data.get('target_users', []),
                    target_roles=notification_data.get('target_roles', []),
                    priority=notification_data.get('priority', 'medium'),
                    related_entity_type=notification_data.get('related_entity_type'),
                    related_entity_id=notification_data.get('related_entity_id'),
                    status='sent'
                )
                db.add(notification)
                db.commit()
                db.refresh(notification)
                return self._notification_to_dict(notification)
            except Exception as e:
                db.rollback()
                raise
            finally:
                db.close()
        else:
            data = self._load_json('notifications.json')
            new_id = max([n['id'] for n in data], default=0) + 1

            new_notification = {
                'id': new_id,
                'title': notification_data['title'],
                'message': notification_data['message'],
                'type': notification_data['type'],
                'target_users': notification_data.get('target_users', []),
                'target_roles': notification_data.get('target_roles', []),
                'priority': notification_data.get('priority', 'medium'),
                'related_entity_type': notification_data.get('related_entity_type'),
                'related_entity_id': notification_data.get('related_entity_id'),
                'created_at': datetime.now().isoformat(),
                'status': 'sent',
                'read_by': []
            }

            data.append(new_notification)
            self._save_json('notifications.json', data)
            return new_notification

    # ============================================================
    # SOP（標準施工手順）
    # ============================================================

    def get_sop_list(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict]:
        """
        SOP一覧を取得

        Args:
            filters: フィルタ条件 (category, search, status など)

        Returns:
            SOPリスト
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                query = db.query(SOP)

                # フィルタリング
                if filters:
                    if 'category' in filters:
                        query = query.filter(SOP.category == filters['category'])
                    if 'status' in filters:
                        query = query.filter(SOP.status == filters['status'])
                    if 'search' in filters:
                        search_term = f"%{filters['search']}%"
                        query = query.filter(
                            (SOP.title.ilike(search_term)) |
                            (SOP.content.ilike(search_term))
                        )

                results = query.order_by(SOP.updated_at.desc()).all()
                return [self._sop_to_dict(s) for s in results]
            finally:
                db.close()
        else:
            data = self._load_json('sop.json')

            # フィルタリング
            if filters:
                if 'category' in filters:
                    data = [s for s in data if s.get('category') == filters['category']]
                if 'status' in filters:
                    data = [s for s in data if s.get('status') == filters['status']]
                if 'search' in filters:
                    search_term = filters['search'].lower()
                    data = [s for s in data if
                           search_term in s.get('title', '').lower() or
                           search_term in s.get('content', '').lower()]

            return data

    def get_sop_by_id(self, sop_id: int) -> Optional[Dict]:
        """
        SOPをIDで取得

        Args:
            sop_id: SOP ID

        Returns:
            SOPデータ（見つからない場合はNone）
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                sop = db.query(SOP).filter(SOP.id == sop_id).first()
                return self._sop_to_dict(sop) if sop else None
            finally:
                db.close()
        else:
            data = self._load_json('sop.json')
            return next((s for s in data if s['id'] == sop_id), None)

    # ============================================================
    # Incident（事故・ヒヤリレポート）
    # ============================================================

    def get_incidents_list(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict]:
        """
        インシデント一覧を取得

        Args:
            filters: フィルタ条件 (project, severity, status など)

        Returns:
            インシデントリスト
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                query = db.query(Incident)

                # フィルタリング
                if filters:
                    if 'project' in filters:
                        query = query.filter(Incident.project == filters['project'])
                    if 'severity' in filters:
                        query = query.filter(Incident.severity == filters['severity'])
                    if 'status' in filters:
                        query = query.filter(Incident.status == filters['status'])
                    if 'search' in filters:
                        search_term = f"%{filters['search']}%"
                        query = query.filter(
                            (Incident.title.ilike(search_term)) |
                            (Incident.description.ilike(search_term))
                        )

                results = query.order_by(Incident.incident_date.desc()).all()
                return [self._incident_to_dict(i) for i in results]
            finally:
                db.close()
        else:
            data = self._load_json('incidents.json')

            # フィルタリング
            if filters:
                if 'project' in filters:
                    data = [i for i in data if i.get('project') == filters['project']]
                if 'severity' in filters:
                    data = [i for i in data if i.get('severity') == filters['severity']]
                if 'status' in filters:
                    data = [i for i in data if i.get('status') == filters['status']]
                if 'search' in filters:
                    search_term = filters['search'].lower()
                    data = [i for i in data if
                           search_term in i.get('title', '').lower() or
                           search_term in i.get('description', '').lower()]

            return sorted(data, key=lambda x: x.get('incident_date', ''), reverse=True)

    def get_incident_by_id(self, incident_id: int) -> Optional[Dict]:
        """
        インシデントをIDで取得

        Args:
            incident_id: インシデントID

        Returns:
            インシデントデータ（見つからない場合はNone）
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                incident = db.query(Incident).filter(Incident.id == incident_id).first()
                return self._incident_to_dict(incident) if incident else None
            finally:
                db.close()
        else:
            data = self._load_json('incidents.json')
            return next((i for i in data if i['id'] == incident_id), None)

    # ============================================================
    # Approval（承認フロー）
    # ============================================================

    def get_approvals_list(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict]:
        """
        承認一覧を取得

        Args:
            filters: フィルタ条件 (status, type, requester_id など)

        Returns:
            承認リスト
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                query = db.query(Approval)

                # フィルタリング
                if filters:
                    if 'status' in filters:
                        query = query.filter(Approval.status == filters['status'])
                    if 'type' in filters:
                        query = query.filter(Approval.type == filters['type'])
                    if 'requester_id' in filters:
                        query = query.filter(Approval.requester_id == filters['requester_id'])
                    if 'priority' in filters:
                        query = query.filter(Approval.priority == filters['priority'])

                results = query.order_by(Approval.created_at.desc()).all()
                return [self._approval_to_dict(a) for a in results]
            finally:
                db.close()
        else:
            data = self._load_json('approvals.json')

            # フィルタリング
            if filters:
                if 'status' in filters:
                    data = [a for a in data if a.get('status') == filters['status']]
                if 'type' in filters:
                    data = [a for a in data if a.get('type') == filters['type']]
                if 'requester_id' in filters:
                    data = [a for a in data if a.get('requester_id') == filters['requester_id']]
                if 'priority' in filters:
                    data = [a for a in data if a.get('priority') == filters['priority']]

            return sorted(data, key=lambda x: x.get('created_at', ''), reverse=True)

    # ============================================================
    # AccessLog（アクセスログ）
    # ============================================================

    def get_access_logs(self, filters: Optional[Dict[str, Any]] = None) -> List[Dict]:
        """
        アクセスログを取得

        Args:
            filters: フィルタ条件 (user_id, action, resource など)

        Returns:
            アクセスログリスト
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                query = db.query(AccessLog)

                # フィルタリング
                if filters:
                    if 'user_id' in filters:
                        query = query.filter(AccessLog.user_id == filters['user_id'])
                    if 'action' in filters:
                        query = query.filter(AccessLog.action == filters['action'])
                    if 'resource' in filters:
                        query = query.filter(AccessLog.resource == filters['resource'])
                    if 'limit' in filters:
                        query = query.limit(filters['limit'])

                results = query.order_by(AccessLog.created_at.desc()).all()
                return [self._access_log_to_dict(log) for log in results]
            finally:
                db.close()
        else:
            data = self._load_json('access_logs.json')

            # フィルタリング
            if filters:
                if 'user_id' in filters:
                    data = [log for log in data if log.get('user_id') == filters['user_id']]
                if 'action' in filters:
                    data = [log for log in data if log.get('action') == filters['action']]
                if 'resource' in filters:
                    data = [log for log in data if log.get('resource') == filters['resource']]

            # ソート
            data = sorted(data, key=lambda x: x.get('created_at', ''), reverse=True)

            # リミット
            if filters and 'limit' in filters:
                data = data[:filters['limit']]

            return data

    def create_access_log(self, log_data: Dict) -> Dict:
        """
        アクセスログを作成

        Args:
            log_data: ログデータ

        Returns:
            作成されたログデータ
        """
        if self.use_postgresql:
            db = SessionLocal()
            try:
                access_log = AccessLog(
                    user_id=log_data.get('user_id'),
                    username=log_data.get('username'),
                    action=log_data['action'],
                    resource=log_data.get('resource'),
                    resource_id=log_data.get('resource_id'),
                    ip_address=log_data.get('ip_address'),
                    user_agent=log_data.get('user_agent')
                )
                db.add(access_log)
                db.commit()
                db.refresh(access_log)
                return self._access_log_to_dict(access_log)
            except Exception as e:
                db.rollback()
                raise
            finally:
                db.close()
        else:
            data = self._load_json('access_logs.json')
            new_id = max([log['id'] for log in data], default=0) + 1

            new_log = {
                'id': new_id,
                'user_id': log_data.get('user_id'),
                'username': log_data.get('username'),
                'action': log_data['action'],
                'resource': log_data.get('resource'),
                'resource_id': log_data.get('resource_id'),
                'ip_address': log_data.get('ip_address'),
                'user_agent': log_data.get('user_agent'),
                'created_at': datetime.now().isoformat()
            }

            data.append(new_log)
            self._save_json('access_logs.json', data)
            return new_log

    # ============================================================
    # ヘルパーメソッド（ORMオブジェクト→辞書変換）
    # ============================================================

    @staticmethod
    def _knowledge_to_dict(knowledge: Knowledge) -> Dict:
        """KnowledgeオブジェクトをDictに変換"""
        if not knowledge:
            return None
        return {
            'id': knowledge.id,
            'title': knowledge.title,
            'summary': knowledge.summary,
            'content': knowledge.content,
            'category': knowledge.category,
            'tags': knowledge.tags or [],
            'status': knowledge.status,
            'priority': knowledge.priority,
            'project': knowledge.project,
            'owner': knowledge.owner,
            'created_at': knowledge.created_at.isoformat() if knowledge.created_at else None,
            'updated_at': knowledge.updated_at.isoformat() if knowledge.updated_at else None,
            'created_by_id': knowledge.created_by_id,
            'updated_by_id': knowledge.updated_by_id
        }

    @staticmethod
    def _notification_to_dict(notification: Notification) -> Dict:
        """NotificationオブジェクトをDictに変換"""
        if not notification:
            return None
        return {
            'id': notification.id,
            'title': notification.title,
            'message': notification.message,
            'type': notification.type,
            'target_users': notification.target_users or [],
            'target_roles': notification.target_roles or [],
            'priority': notification.priority,
            'related_entity_type': notification.related_entity_type,
            'related_entity_id': notification.related_entity_id,
            'created_at': notification.created_at.isoformat() if notification.created_at else None,
            'sent_at': notification.sent_at.isoformat() if notification.sent_at else None,
            'status': notification.status
        }

    @staticmethod
    def _sop_to_dict(sop: SOP) -> Dict:
        """SOPオブジェクトをDictに変換"""
        if not sop:
            return None
        return {
            'id': sop.id,
            'title': sop.title,
            'category': sop.category,
            'version': sop.version,
            'revision_date': sop.revision_date.isoformat() if sop.revision_date else None,
            'target': sop.target,
            'tags': sop.tags or [],
            'content': sop.content,
            'status': sop.status,
            'supersedes_id': sop.supersedes_id,
            'attachments': sop.attachments,
            'created_at': sop.created_at.isoformat() if sop.created_at else None,
            'updated_at': sop.updated_at.isoformat() if sop.updated_at else None,
            'created_by_id': sop.created_by_id,
            'updated_by_id': sop.updated_by_id
        }

    @staticmethod
    def _incident_to_dict(incident: Incident) -> Dict:
        """IncidentオブジェクトをDictに変換"""
        if not incident:
            return None
        return {
            'id': incident.id,
            'title': incident.title,
            'description': incident.description,
            'project': incident.project,
            'incident_date': incident.incident_date.isoformat() if incident.incident_date else None,
            'severity': incident.severity,
            'status': incident.status,
            'corrective_actions': incident.corrective_actions,
            'root_cause': incident.root_cause,
            'tags': incident.tags or [],
            'location': incident.location,
            'involved_parties': incident.involved_parties or [],
            'created_at': incident.created_at.isoformat() if incident.created_at else None,
            'updated_at': incident.updated_at.isoformat() if incident.updated_at else None,
            'reporter_id': incident.reporter_id
        }

    @staticmethod
    def _approval_to_dict(approval: Approval) -> Dict:
        """ApprovalオブジェクトをDictに変換"""
        if not approval:
            return None
        return {
            'id': approval.id,
            'title': approval.title,
            'type': approval.type,
            'description': approval.description,
            'requester_id': approval.requester_id,
            'status': approval.status,
            'priority': approval.priority,
            'related_entity_type': approval.related_entity_type,
            'related_entity_id': approval.related_entity_id,
            'approval_flow': approval.approval_flow,
            'created_at': approval.created_at.isoformat() if approval.created_at else None,
            'updated_at': approval.updated_at.isoformat() if approval.updated_at else None,
            'approved_at': approval.approved_at.isoformat() if approval.approved_at else None,
            'approver_id': approval.approver_id
        }

    @staticmethod
    def _access_log_to_dict(log: AccessLog) -> Dict:
        """AccessLogオブジェクトをDictに変換"""
        if not log:
            return None
        return {
            'id': log.id,
            'user_id': log.user_id,
            'username': log.username,
            'action': log.action,
            'resource': log.resource,
            'resource_id': log.resource_id,
            'ip_address': str(log.ip_address) if log.ip_address else None,
            'user_agent': log.user_agent,
            'created_at': log.created_at.isoformat() if log.created_at else None
        }


# グローバルインスタンス
dal = DataAccessLayer()
